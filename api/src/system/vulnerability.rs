use crate::db::{ConnectionOrTransaction, Transactional};
use huevos_common::package::vulnerabilities::{PackageVulnerability, TaggedPackageVulnerability};
use huevos_common::package::{PackageTree, VulnerabilityTree};
use huevos_common::purl::Purl;
use huevos_entity::vulnerability_fixed::VulnerabilityFixed;
use huevos_entity::{package_scan_vulnerability, scanner, vulnerability, vulnerability_fixed};
use sea_orm::prelude::DateTimeWithTimeZone;
use sea_orm::{
    ActiveModelTrait, ColumnTrait, ConnectionTrait, EntityTrait, FromQueryResult, QueryFilter,
    QuerySelect, QueryTrait, RelationTrait, Set, Statement,
};
use sea_query::{Condition, Expr, JoinType, OnConflict, Value};
use crate::system::error::Error;

use crate::system::System;

impl System {
    pub async fn ingest_vulnerability(
        &self,
        identifier: &str,
    ) -> Result<vulnerability::Model, anyhow::Error> {
        match vulnerability::Entity::find()
            .filter(Condition::all().add(vulnerability::Column::Identifier.eq(identifier)))
            .one(&*self.db)
            .await?
        {
            None => {
                let entity = vulnerability::ActiveModel {
                    identifier: Set(identifier.to_string()),
                    ..Default::default()
                };

                Ok(entity.insert(&*self.db).await?)
            }
            Some(found) => Ok(found),
        }
    }

    pub async fn vulnerabilities(&self) -> Result<Vec<vulnerability::Model>, anyhow::Error> {
        Ok(vulnerability::Entity::find().all(&*self.db).await?)
    }

    pub async fn ingest_scanner(&self, scanner: &str, tx: Transactional<'_>) -> Result<scanner::Model, Error> {
        if let Some(found) = scanner::Entity::find()
            .filter(scanner::Column::Name.eq( scanner.to_string() ))
            .one(&self.connection(tx))
            .await? {
            Ok(found)
        } else {
            let model = scanner::ActiveModel {
                name: Set(scanner.to_string()),
                    ..Default::default()
            };

            Ok(model.insert(
                &self.connection(tx)
            ).await?)
        }

    }

    pub async fn ingest_package_vulnerability<'p, P: Into<Purl>>(
        &self,
        package: P,
        vulnerability_identifier: &str,
        scanner: &str,
        tx: Transactional<'_>,
    ) -> Result<package_scan_vulnerability::Model, anyhow::Error> {
        let package = self.ingest_package(package, tx).await?;
        let scanner = self.ingest_scanner(scanner, tx).await?;

        let vulnerability = self.ingest_vulnerability(vulnerability_identifier).await?;

        match package_scan_vulnerability::Entity::find()
            .filter(
                Condition::all()
                    .add(package_scan_vulnerability::Column::PackageId.eq(package.id))
                    .add(package_scan_vulnerability::Column::VulnerabilityId.eq(vulnerability.id))
                    .add(package_scan_vulnerability::Column::ScannerId.eq(scanner.id)),
            )
            .one(&self.connection(tx))
            .await?
        {
            None => Ok(package_scan_vulnerability::ActiveModel {
                package_id: Set(package.id),
                vulnerability_id: Set(vulnerability.id),
                scanner_id: Set(scanner.id ),
                ..Default::default()
            }
            .insert(&*self.db)
            .await?),
            Some(found) => Ok(found),
        }
    }

    pub async fn direct_vulnerabilities<'p, P: Into<Purl>>(
        &self,
        package: P,
        tx: Transactional<'_>,
    ) -> Result<Vec<PackageVulnerability>, anyhow::Error> {
        let package_id = self.ingest_package(package, tx).await?.id;

        Ok(vulnerability::Entity::find()
            .join_rev(
                JoinType::FullOuterJoin,
                package_scan_vulnerability::Relation::Vulnerability.def(),
            )
            .join(
                JoinType::FullOuterJoin,
                package_scan_vulnerability::Relation::Package.def(),
            )
            .join(
                JoinType::LeftJoin,
                package_scan_vulnerability::Relation::Scanner.def()
            )
            .column_as(scanner::Column::Name, "scanner" )
            .having(package_scan_vulnerability::Column::PackageId.eq(package_id))
            .group_by(vulnerability::Column::Id)
            .group_by(package_scan_vulnerability::Column::Id)
            .group_by(scanner::Column::Name)
            .into_model::<PackageVulnerability>()
            .all(&self.connection(tx))
            .await?)
    }

    pub async fn transitive_vulnerabilities<'p, P: Into<Purl>>(
        &self,
        package: P,
        tx: Transactional<'_>,
    ) -> Result<VulnerabilityTree, anyhow::Error> {
        let purl = package.into();
        let package_id = self.ingest_package(purl.clone(), tx).await?.id;

        let tagged_vulns = vulnerability::Entity::find()
            .from_raw_sql(
                Statement::from_sql_and_values(
                    self.db.get_database_backend(),
                    r#"
                    WITH RECURSIVE transitive AS (
                        SELECT
                            timestamp, dependent_package_id, dependency_package_id
                        FROM
                            package_dependency
                        WHERE
                            dependent_package_id = $1
                        UNION
                        SELECT
                            pd.timestamp, pd.dependent_package_id, pd.dependency_package_id
                        FROM
                            package_dependency pd
                        INNER JOIN transitive transitive1
                            ON pd.dependent_package_id = transitive1.dependency_package_id
                    )
                    SELECT
                        vulnerability.identifier,
                        package_scan_vulnerability.scanner_id,
                        package_scan_vulnerability.timestamp,
                        package_scan_vulnerability.package_id,
                        scanner.name as scanner
                    FROM
                        vulnerability
                    INNER JOIN
                        package_scan_vulnerability ON package_scan_vulnerability.vulnerability_id = vulnerability.id
                    LEFT JOIN
                        scanner ON package_scan_vulnerability.scanner_id = scanner.id
                    WHERE package_scan_vulnerability.package_id IN
                        (SELECT dependency_package_id FROM transitive)
                    GROUP BY vulnerability.identifier, package_scan_vulnerability.id, scanner.name
                    "#,
                    vec![Value::Int(Some(package_id))]
                )
            )
            .into_model::<TaggedPackageVulnerability>()
            .all(
                &self.connection(tx)
            )
            .await?;

        let tree = self.transitive_package_dependencies(purl, tx).await?;

        Ok(tree.merge_vulnerabilities(&tagged_vulns))
    }

    /// Ingest a record that a vulnerability has been fixed for a certain PURL
    pub async fn ingest_vulnerability_fixed<'p, P: Into<Purl>>(
        &self,
        package: P,
        vulnerability: &vulnerability::Model,
        source: &str,
    ) -> Result<(), anyhow::Error> {
        let model = vulnerability_fixed::ActiveModel {
            purl: Set(package.into().to_string()),
            vulnerability_id: Set(vulnerability.id),
            source: Set(source.to_string()),
        };

        self.db
            .execute(
                vulnerability_fixed::Entity::insert(model)
                    .on_conflict(OnConflict::new().do_nothing().to_owned())
                    .build(self.db.get_database_backend()),
            )
            .await?;

        Ok(())
    }

    pub async fn is_fixed(&self, vuln: &str, purl: impl Into<Purl>) -> Result<bool, anyhow::Error> {
        let purl = purl.into().to_string();

        Ok(vulnerability_fixed::Entity::find()
            .join(
                JoinType::LeftJoin,
                vulnerability_fixed::Relation::Vulnerability.def(),
            )
            .filter(vulnerability_fixed::Column::Purl.eq(&purl))
            .filter(vulnerability::Column::Identifier.eq(vuln))
            .one(&*self.db)
            .await?
            .is_some())
    }
}

#[cfg(test)]
mod tests {
    use crate::db::Transactional;
    use crate::system::System;

    #[tokio::test]
    async fn ingest_vulnerabilities() -> Result<(), anyhow::Error> {
        let system = System::for_test("ingest_vulnerabilities").await?;

        system.ingest_vulnerability("CVE-123").await?;

        system.ingest_vulnerability("CVE-123").await?;

        system.ingest_vulnerability("CVE-123").await?;

        system.ingest_vulnerability("CVE-456").await?;

        system.ingest_vulnerability("CVE-456").await?;

        let vulns = system.vulnerabilities().await?;

        println!("{:#?}", vulns);

        Ok(())
    }

    #[tokio::test]
    async fn ingest_package_vulnerability() -> Result<(), anyhow::Error> {
        env_logger::builder()
            .filter_level(log::LevelFilter::Debug)
            .is_test(true)
            .init();

        let system = System::for_test("ingest_package_vulnerabilities").await?;

        system.ingest_vulnerability("CVE-123").await?;

        system.ingest_vulnerability("CVE-123").await?;

        system.ingest_vulnerability("CVE-123").await?;

        system.ingest_vulnerability("CVE-456").await?;
        system.ingest_vulnerability("CVE-8675309").await?;

        system
            .ingest_package_vulnerability(
                "pkg:maven/io.quarkus/another-package@2.13.5.Final?type=jar",
                "CVE-8675309",
                "osv",
                Transactional::None,
            )
            .await?;

        system
            .ingest_package_vulnerability(
                "pkg:maven/io.quarkus/quarkus-jdbc-postgresql@2.13.5.Final?type=jar",
                "CVE-123",
                "osv",
                Transactional::None,
            )
            .await?;

        system
            .ingest_package_vulnerability(
                "pkg:maven/io.quarkus/quarkus-jdbc-postgresql@2.13.5.Final?type=jar",
                "CVE-123",
                "snyk",
                Transactional::None,
            )
            .await?;

        let found = system
            .direct_vulnerabilities(
                "pkg:maven/io.quarkus/quarkus-jdbc-postgresql@2.13.5.Final?type=jar",
                Transactional::None,
            )
            .await?;

        println!("{:#?}", found);

        Ok(())
    }

    #[tokio::test]
    async fn transitive_vulnerabilities() -> Result<(), anyhow::Error> {
        //env_logger::builder()
        //.filter_level(log::LevelFilter::Info)
        //.is_test(true)
        //.init();

        let system = System::for_test("transitive_vulnerabilities").await?;

        let sbom = system
            .ingest_sbom("http://test.com/transitive-vulnerabilities.json", "11")
            .await?;

        system.ingest_vulnerability("CVE-1").await?;
        system.ingest_vulnerability("CVE-2").await?;
        system.ingest_vulnerability("CVE-3").await?;

        system
            .ingest_package("pkg:maven/a@1.0", Transactional::None)
            .await?;

        system
            .ingest_package("pkg:maven/b@1.0", Transactional::None)
            .await?;

        system
            .ingest_package("pkg:maven/c@1.0", Transactional::None)
            .await?;

        system
            .ingest_package_dependency(
                "pkg:maven/a@1.0",
                "pkg:maven/b@1.0",
                &sbom,
                Transactional::None,
            )
            .await?;

        system
            .ingest_package_dependency(
                "pkg:maven/b@1.0",
                "pkg:maven/c@1.0",
                &sbom,
                Transactional::None,
            )
            .await?;

        system
            .ingest_package_vulnerability("pkg:maven/c@1.0", "CVE-1", "snyk", Transactional::None)
            .await?;
        system
            .ingest_package_vulnerability("pkg:maven/c@1.0", "CVE-2", "osv", Transactional::None)
            .await?;

        let vulns = system
            .transitive_vulnerabilities("pkg:maven/a@1.0", Transactional::None)
            .await?;

        //assert_eq!(1, vulns.len());
        println!("{:#?}", vulns);

        Ok(())
    }

    #[tokio::test]
    async fn vuln_fixed() -> Result<(), anyhow::Error> {
        /*
        env_logger::builder()
            .filter_level(log::LevelFilter::Info)
            .is_test(true)
            .init();

         */

        let system = System::for_test("vuln_fixed").await?;

        let cve1 = system.ingest_vulnerability("CVE-1").await?;

        system
            .ingest_vulnerability_fixed("pkg:maven/a@1.0", &cve1, "vex")
            .await?;
        // duplicate
        system
            .ingest_vulnerability_fixed("pkg:maven/a@1.0", &cve1, "vex")
            .await?;
        // different source
        system
            .ingest_vulnerability_fixed("pkg:maven/a@1.0", &cve1, "test")
            .await?;

        let fixed = system.is_fixed("CVE-1", "pkg:maven/a@1.0").await?;
        assert!(fixed);

        let fixed = system.is_fixed("CVE-1", "pkg:maven/a@1.1").await?;
        assert!(!fixed);

        Ok(())
    }
}
