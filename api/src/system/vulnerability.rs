use huevos_common::package::vulnerabilities::{PackageVulnerability, TaggedPackageVulnerability};
use huevos_common::package::{PackageTree, VulnerabilityTree};
use huevos_common::purl::Purl;
use huevos_entity::vulnerability_fixed::VulnerabilityFixed;
use huevos_entity::{package_vulnerability, vulnerability, vulnerability_fixed};
use sea_orm::prelude::DateTimeWithTimeZone;
use sea_orm::{
    ActiveModelTrait, ColumnTrait, ConnectionTrait, EntityTrait, FromQueryResult, QueryFilter,
    QuerySelect, QueryTrait, RelationTrait, Set, Statement,
};
use sea_query::{Condition, JoinType, OnConflict, Value};

use crate::system::System;

impl System {
    pub async fn ingest_vulnerability(
        &self,
        identifier: &str,
    ) -> Result<vulnerability::Model, anyhow::Error> {
        match vulnerability::Entity::find()
            .filter(Condition::all().add(vulnerability::Column::Identifier.eq(identifier)))
            .one(&*self.db)
            .await?
        {
            None => {
                let entity = vulnerability::ActiveModel {
                    identifier: Set(identifier.to_string()),
                    ..Default::default()
                };

                Ok(entity.insert(&*self.db).await?)
            }
            Some(found) => Ok(found),
        }
    }

    pub async fn vulnerabilities(&self) -> Result<Vec<vulnerability::Model>, anyhow::Error> {
        Ok(vulnerability::Entity::find().all(&*self.db).await?)
    }

    pub async fn ingest_package_vulnerability<'p, P: Into<Purl>>(
        &self,
        package: P,
        vulnerability_identifier: &str,
        source: &str,
    ) -> Result<package_vulnerability::Model, anyhow::Error> {
        let package = self.ingest_package(package).await?;

        let vulnerability = self.ingest_vulnerability(vulnerability_identifier).await?;

        match package_vulnerability::Entity::find()
            .filter(
                Condition::all()
                    .add(package_vulnerability::Column::PackageId.eq(package.id))
                    .add(package_vulnerability::Column::VulnerabilityId.eq(vulnerability.id))
                    .add(package_vulnerability::Column::Source.eq(source.to_string())),
            )
            .one(&*self.db)
            .await?
        {
            None => Ok(package_vulnerability::ActiveModel {
                package_id: Set(package.id),
                vulnerability_id: Set(vulnerability.id),
                source: Set(source.to_string()),
                ..Default::default()
            }
            .insert(&*self.db)
            .await?),
            Some(found) => Ok(found),
        }
    }

    pub async fn direct_vulnerabilities<'p, P: Into<Purl>>(
        &self,
        package: P,
    ) -> Result<Vec<PackageVulnerability>, anyhow::Error> {
        let package_id = self.ingest_package(package).await?.id;

        Ok(vulnerability::Entity::find()
            .join_rev(
                JoinType::FullOuterJoin,
                package_vulnerability::Relation::Vulnerability.def(),
            )
            .join(
                JoinType::FullOuterJoin,
                package_vulnerability::Relation::Package.def(),
            )
            .column(package_vulnerability::Column::Source)
            .having(package_vulnerability::Column::PackageId.eq(package_id))
            .group_by(vulnerability::Column::Id)
            .group_by(package_vulnerability::Column::Id)
            .into_model::<PackageVulnerability>()
            .all(&*self.db)
            .await?)
    }

    pub async fn transitive_vulnerabilities<'p, P: Into<Purl>>(
        &self,
        package: P,
    ) -> Result<VulnerabilityTree, anyhow::Error> {
        let purl = package.into();
        let package_id = self.ingest_package(purl.clone()).await?.id;

        let tagged_vulns = vulnerability::Entity::find()
            .from_raw_sql(
                Statement::from_sql_and_values(
                    self.db.get_database_backend(),
                    r#"
                    WITH RECURSIVE transitive AS (
                        SELECT
                            timestamp, dependent_package_id, dependency_package_id
                        FROM
                            package_dependency
                        WHERE
                            dependent_package_id = $1
                        UNION
                        SELECT
                            pd.timestamp, pd.dependent_package_id, pd.dependency_package_id
                        FROM
                            package_dependency pd
                        INNER JOIN transitive transitive1
                            ON pd.dependent_package_id = transitive1.dependency_package_id
                    )
                    SELECT
                        vulnerability.identifier,
                        package_vulnerability.source,
                        package_vulnerability.timestamp,
                        package_vulnerability.package_id
                    FROM
                        vulnerability
                    INNER JOIN
                        package_vulnerability ON package_vulnerability.vulnerability_id = vulnerability.id
                    WHERE package_vulnerability.package_id IN
                        (SELECT dependency_package_id FROM transitive)
                    GROUP BY vulnerability.identifier, package_vulnerability.id
                    "#,
                    vec![Value::Int(Some(package_id))]
                )
            )
            .into_model::<TaggedPackageVulnerability>()
            .all(&*self.db)
            .await?;

        let tree = self.transitive_package_dependencies(purl).await?;

        Ok(tree.merge_vulnerabilities(&tagged_vulns))
    }

    /// Ingest a record that a vulnerability has been fixed for a certain PURL
    pub async fn ingest_vulnerability_fixed<'p, P: Into<Purl>>(
        &self,
        package: P,
        vulnerability: &vulnerability::Model,
        source: &str,
    ) -> Result<(), anyhow::Error> {
        let model = vulnerability_fixed::ActiveModel {
            purl: Set(package.into().to_string()),
            vulnerability_id: Set(vulnerability.id),
            source: Set(source.to_string()),
        };

        self.db
            .execute(
                vulnerability_fixed::Entity::insert(model)
                    .on_conflict(OnConflict::new().do_nothing().to_owned())
                    .build(self.db.get_database_backend()),
            )
            .await?;

        Ok(())
    }

    pub async fn is_fixed(&self, vuln: &str, purl: impl Into<Purl>) -> Result<bool, anyhow::Error> {
        let purl = purl.into().to_string();

        Ok(vulnerability_fixed::Entity::find()
            .join(
                JoinType::LeftJoin,
                vulnerability_fixed::Relation::Vulnerability.def(),
            )
            .filter(vulnerability_fixed::Column::Purl.eq(&purl))
            .filter(vulnerability::Column::Identifier.eq(vuln))
            .one(&*self.db)
            .await?
            .is_some())
    }
}

#[cfg(test)]
mod tests {
    use crate::system::System;

    #[tokio::test]
    async fn ingest_vulnerabilities() -> Result<(), anyhow::Error> {
        let system = System::for_test("ingest_vulnerabilities").await?;

        system.ingest_vulnerability("CVE-123").await?;

        system.ingest_vulnerability("CVE-123").await?;

        system.ingest_vulnerability("CVE-123").await?;

        system.ingest_vulnerability("CVE-456").await?;

        system.ingest_vulnerability("CVE-456").await?;

        let vulns = system.vulnerabilities().await?;

        println!("{:#?}", vulns);

        Ok(())
    }

    #[tokio::test]
    async fn ingest_package_vulnerability() -> Result<(), anyhow::Error> {
        env_logger::builder()
            .filter_level(log::LevelFilter::Debug)
            .is_test(true)
            .init();

        let system = System::for_test("ingest_package_vulnerabilities").await?;

        system.ingest_vulnerability("CVE-123").await?;

        system.ingest_vulnerability("CVE-123").await?;

        system.ingest_vulnerability("CVE-123").await?;

        system.ingest_vulnerability("CVE-456").await?;
        system.ingest_vulnerability("CVE-8675309").await?;

        system
            .ingest_package_vulnerability(
                "pkg:maven/io.quarkus/another-package@2.13.5.Final?type=jar",
                "CVE-8675309",
                "osv",
            )
            .await?;

        system
            .ingest_package_vulnerability(
                "pkg:maven/io.quarkus/quarkus-jdbc-postgresql@2.13.5.Final?type=jar",
                "CVE-123",
                "osv",
            )
            .await?;

        system
            .ingest_package_vulnerability(
                "pkg:maven/io.quarkus/quarkus-jdbc-postgresql@2.13.5.Final?type=jar",
                "CVE-123",
                "snyk",
            )
            .await?;

        let found = system
            .direct_vulnerabilities(
                "pkg:maven/io.quarkus/quarkus-jdbc-postgresql@2.13.5.Final?type=jar",
            )
            .await?;

        println!("{:#?}", found);

        Ok(())
    }

    #[tokio::test]
    async fn transitive_vulnerabilities() -> Result<(), anyhow::Error> {
        //env_logger::builder()
        //.filter_level(log::LevelFilter::Info)
        //.is_test(true)
        //.init();

        let system = System::for_test("transitive_vulnerabilities").await?;

        let sbom = system.ingest_sbom(
            "http://test.com/transitive-vulnerabilities.json",
        ).await?;

        system.ingest_vulnerability("CVE-1").await?;
        system.ingest_vulnerability("CVE-2").await?;
        system.ingest_vulnerability("CVE-3").await?;

        system.ingest_package("pkg:maven/a@1.0").await?;

        system.ingest_package("pkg:maven/b@1.0").await?;

        system.ingest_package("pkg:maven/c@1.0").await?;

        system
            .ingest_package_dependency("pkg:maven/a@1.0", "pkg:maven/b@1.0", &sbom)
            .await?;

        system
            .ingest_package_dependency("pkg:maven/b@1.0", "pkg:maven/c@1.0", &sbom)
            .await?;

        system
            .ingest_package_vulnerability("pkg:maven/c@1.0", "CVE-1", "snyk")
            .await?;
        system
            .ingest_package_vulnerability("pkg:maven/c@1.0", "CVE-2", "osv")
            .await?;

        let vulns = system.transitive_vulnerabilities("pkg:maven/a@1.0").await?;

        //assert_eq!(1, vulns.len());
        println!("{:#?}", vulns);

        Ok(())
    }

    #[tokio::test]
    async fn vuln_fixed() -> Result<(), anyhow::Error> {
        /*
        env_logger::builder()
            .filter_level(log::LevelFilter::Info)
            .is_test(true)
            .init();

         */

        let system = System::for_test("vuln_fixed").await?;

        let cve1 = system.ingest_vulnerability("CVE-1").await?;

        system
            .ingest_vulnerability_fixed("pkg:maven/a@1.0", &cve1, "vex")
            .await?;
        // duplicate
        system
            .ingest_vulnerability_fixed("pkg:maven/a@1.0", &cve1, "vex")
            .await?;
        // different source
        system
            .ingest_vulnerability_fixed("pkg:maven/a@1.0", &cve1, "test")
            .await?;

        let fixed = system.is_fixed("CVE-1", "pkg:maven/a@1.0").await?;
        assert!(fixed);

        let fixed = system.is_fixed("CVE-1", "pkg:maven/a@1.1").await?;
        assert!(!fixed);

        Ok(())
    }
}
