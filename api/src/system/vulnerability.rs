use sea_orm::prelude::DateTimeWithTimeZone;
use sea_orm::{
    ActiveModelTrait, ColumnTrait, ConnectionTrait, EntityTrait, FromQueryResult, QueryFilter,
    QuerySelect, RelationTrait, Set, Statement,
};
use sea_query::{Condition, JoinType, Value};

use huevos_entity::package_vulnerability::PackageVulnerability;
use huevos_entity::{package_vulnerability, vulnerability};

use crate::system::System;
use crate::{PackageTree, Purl, VulnerabilityTree};

impl System {
    pub async fn ingest_vulnerability(
        &self,
        identifier: &str,
    ) -> Result<vulnerability::Model, anyhow::Error> {
        match vulnerability::Entity::find()
            .filter(Condition::all().add(vulnerability::Column::Identifier.eq(identifier.clone())))
            .one(&*self.db)
            .await?
        {
            None => {
                let entity = vulnerability::ActiveModel {
                    identifier: Set(identifier.to_string()),
                    ..Default::default()
                };

                Ok(entity.insert(&*self.db).await?)
            }
            Some(found) => Ok(found),
        }
    }

    pub async fn vulnerabilities(&self) -> Result<Vec<vulnerability::Model>, anyhow::Error> {
        Ok(vulnerability::Entity::find().all(&*self.db).await?)
    }

    pub async fn ingest_package_vulnerability<'p, P: Into<Purl>>(
        &self,
        package: P,
        vulnerability_identifier: &str,
        source: &str,
    ) -> Result<package_vulnerability::Model, anyhow::Error> {
        let package = self.ingest_package(package).await?;

        let vulnerability = self.ingest_vulnerability(vulnerability_identifier).await?;

        match package_vulnerability::Entity::find()
            .filter(
                Condition::all()
                    .add(package_vulnerability::Column::PackageId.eq(package.id))
                    .add(package_vulnerability::Column::VulnerabilityId.eq(vulnerability.id))
                    .add(package_vulnerability::Column::Source.eq(source.to_string())),
            )
            .one(&*self.db)
            .await?
        {
            None => Ok(package_vulnerability::ActiveModel {
                package_id: Set(package.id),
                vulnerability_id: Set(vulnerability.id),
                source: Set(source.to_string()),
                ..Default::default()
            }
            .insert(&*self.db)
            .await?),
            Some(found) => Ok(found),
        }
    }

    pub async fn direct_vulnerabilities<'p, P: Into<Purl>>(
        &self,
        package: P,
    ) -> Result<Vec<PackageVulnerability>, anyhow::Error> {
        let package_id = self.ingest_package(package).await?.id;

        Ok(vulnerability::Entity::find()
            .join_rev(
                JoinType::FullOuterJoin,
                package_vulnerability::Relation::Vulnerability.def(),
            )
            .join(
                JoinType::FullOuterJoin,
                package_vulnerability::Relation::Package.def(),
            )
            .column(package_vulnerability::Column::Source)
            .having(package_vulnerability::Column::PackageId.eq(package_id))
            .group_by(vulnerability::Column::Id)
            .group_by(package_vulnerability::Column::Id)
            .into_model::<PackageVulnerability>()
            .all(&*self.db)
            .await?)
    }

    pub async fn transitive_vulnerabilities<'p, P: Into<Purl>>(
        &self,
        package: P,
    ) -> Result<VulnerabilityTree, anyhow::Error> {
        let purl = package.into();
        let package_id = self.ingest_package(purl.clone()).await?.id;

        let tagged_vulns = vulnerability::Entity::find()
            .from_raw_sql(
                Statement::from_sql_and_values(
                    self.db.get_database_backend(),
                    r#"
                    WITH RECURSIVE transitive AS (
                        SELECT
                            timestamp, dependent_package_id, dependency_package_id
                        FROM
                            package_dependency
                        WHERE
                            dependent_package_id = $1
                        UNION
                        SELECT
                            pd.timestamp, pd.dependent_package_id, pd.dependency_package_id
                        FROM
                            package_dependency pd
                        INNER JOIN transitive transitive1
                            ON pd.dependent_package_id = transitive1.dependency_package_id
                    )
                    SELECT
                        vulnerability.identifier,
                        package_vulnerability.source,
                        package_vulnerability.timestamp,
                        package_vulnerability.package_id
                    FROM
                        vulnerability
                    INNER JOIN
                        package_vulnerability ON package_vulnerability.vulnerability_id = vulnerability.id
                    WHERE package_vulnerability.package_id IN
                        (SELECT dependency_package_id FROM transitive)
                    GROUP BY vulnerability.identifier, package_vulnerability.id
                    "#,
                    vec![Value::Int(Some(package_id))]
                )
            )
            .into_model::<TaggedPackageVulnerability>()
            .all(&*self.db)
            .await?;

        let tree = self.transitive_dependencies(purl).await?;

        Ok(tree.merge_vulnerabilities(&tagged_vulns))
    }
}

#[derive(FromQueryResult, Debug)]
struct TaggedPackageVulnerability {
    package_id: i32,
    identifier: String,
    source: String,
    timestamp: DateTimeWithTimeZone,
}

impl PackageTree {
    fn merge_vulnerabilities(&self, vulns: &Vec<TaggedPackageVulnerability>) -> VulnerabilityTree {
        VulnerabilityTree {
            purl: self.purl.clone(),
            vulnerabilities: vulns
                .iter()
                .filter(|e| e.package_id == self.id)
                .map(|e| PackageVulnerability {
                    identifier: e.identifier.clone(),
                    source: e.source.clone(),
                    timestamp: e.timestamp,
                })
                .collect(),
            dependencies: self
                .dependencies
                .iter()
                .map(|e| e.merge_vulnerabilities(vulns).clone())
                .collect(),
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::system::System;

    #[tokio::test]
    async fn ingest_vulnerabilities() -> Result<(), anyhow::Error> {
        let system = System::for_test("ingest_vulnerabilities").await?;

        system.ingest_vulnerability("CVE-123").await?;

        system.ingest_vulnerability("CVE-123").await?;

        system.ingest_vulnerability("CVE-123").await?;

        system.ingest_vulnerability("CVE-456").await?;

        system.ingest_vulnerability("CVE-456").await?;

        let vulns = system.vulnerabilities().await?;

        println!("{:#?}", vulns);

        Ok(())
    }

    #[tokio::test]
    async fn ingest_package_vulnerability() -> Result<(), anyhow::Error> {
        env_logger::builder()
            .filter_level(log::LevelFilter::Debug)
            .is_test(true)
            .init();

        let system = System::for_test("ingest_package_vulnerabilities").await?;

        system.ingest_vulnerability("CVE-123").await?;

        system.ingest_vulnerability("CVE-123").await?;

        system.ingest_vulnerability("CVE-123").await?;

        system.ingest_vulnerability("CVE-456").await?;
        system.ingest_vulnerability("CVE-8675309").await?;

        system
            .ingest_package_vulnerability(
                "pkg:maven/io.quarkus/another-package@2.13.5.Final?type=jar",
                "CVE-8675309",
                "osv",
            )
            .await?;

        system
            .ingest_package_vulnerability(
                "pkg:maven/io.quarkus/quarkus-jdbc-postgresql@2.13.5.Final?type=jar",
                "CVE-123",
                "osv",
            )
            .await?;

        system
            .ingest_package_vulnerability(
                "pkg:maven/io.quarkus/quarkus-jdbc-postgresql@2.13.5.Final?type=jar",
                "CVE-123",
                "snyk",
            )
            .await?;

        let found = system
            .direct_vulnerabilities(
                "pkg:maven/io.quarkus/quarkus-jdbc-postgresql@2.13.5.Final?type=jar",
            )
            .await?;

        println!("{:#?}", found);

        Ok(())
    }

    #[tokio::test]
    async fn transitive_vulnerabilities() -> Result<(), anyhow::Error> {
        //env_logger::builder()
        //.filter_level(log::LevelFilter::Info)
        //.is_test(true)
        //.init();

        let system = System::for_test("transitive_vulnerabilities").await?;

        system.ingest_vulnerability("CVE-1").await?;
        system.ingest_vulnerability("CVE-2").await?;
        system.ingest_vulnerability("CVE-3").await?;

        system.ingest_package("pkg:maven/a@1.0").await?;

        system.ingest_package("pkg:maven/b@1.0").await?;

        system.ingest_package("pkg:maven/c@1.0").await?;

        system
            .ingest_package_dependency("pkg:maven/a@1.0", "pkg:maven/b@1.0")
            .await?;

        system
            .ingest_package_dependency("pkg:maven/b@1.0", "pkg:maven/c@1.0")
            .await?;

        system
            .ingest_package_vulnerability("pkg:maven/c@1.0", "CVE-1", "snyk")
            .await?;
        system
            .ingest_package_vulnerability("pkg:maven/c@1.0", "CVE-2", "osv")
            .await?;

        let vulns = system.transitive_vulnerabilities("pkg:maven/a@1.0").await?;

        //assert_eq!(1, vulns.len());
        println!("{:#?}", vulns);

        Ok(())
    }
}
